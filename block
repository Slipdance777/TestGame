<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Breakout - Photo Edition</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#05070a; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; }
    #wrap { height: 100%; display:flex; align-items:center; justify-content:center; }
    canvas { width: min(96vw, 900px); height: min(92vh, 1500px); border-radius: 14px; box-shadow: 0 18px 80px rgba(0,0,0,.55); background:#000; touch-action:none; }
    .hint {
      position: fixed; left: 12px; bottom: 10px; right: 12px;
      display:flex; gap:10px; flex-wrap:wrap;
      color: rgba(255,255,255,.72); font-size: 12px; line-height: 1.2;
      justify-content: space-between;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
    }
    .pill { background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.12); padding: 6px 10px; border-radius: 999px; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="720" height="1280" aria-label="Breakout game"></canvas>
</div>
<div class="hint">
  <div class="pill">操作: マウス/タッチ/←→ / Space(開始・ポーズ) / R(リスタート) / M(ミュート)</div>
  <div class="pill">最初にクリック/タップで音が有効化されます</div>
</div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp  = (a, b, t) => a + (b - a) * t;
  const rand  = (a, b) => a + Math.random() * (b - a);

  const bg = new Image();
  bg.src = "bg.jpg";
  let bgReady = false;
  bg.onload = () => { bgReady = true; };
  bg.onerror = () => { bgReady = false; };

  const W = canvas.width, H = canvas.height;
  let running = false;
  let paused = false;
  let gameOver = false;
  let startedOnce = false;

  let shake = 0;

  let score = 0;
  let combo = 0;
  let level = 1;
  let lives = 3;
  let best = Number(localStorage.getItem("breakout_best") || "0");

  const powerups = [];
  let laserTime = 0;

  const particles = [];

  const paddle = {
    x: W * 0.5,
    y: H - 110,
    w: 160,
    h: 18,
    targetX: W * 0.5,
    speed: 0.18,
  };

  const balls = [];
  function spawnBall(x, y, speedMul = 1) {
    const angle = rand(-Math.PI * 0.75, -Math.PI * 0.25);
    const spd = (9.2 + level * 0.55) * speedMul;
    balls.push({ x, y, r: 10, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd, stuck: true, trail: [] });
  }

  let bricks = [];
  function buildLevel(lv) {
    const cols = clamp(8 + Math.floor(lv/2), 8, 12);
    const rows = clamp(5 + Math.floor(lv/2), 5, 10);
    const marginX = 44, topY = 140, gap = 10;
    const brickW = (W - marginX*2 - gap*(cols-1)) / cols;
    const brickH = 34;

    bricks = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const hp = 1 + (lv >= 3 ? (Math.random() < 0.18 ? 2 : 1) : 0) + (lv >= 6 ? (Math.random() < 0.10 ? 2 : 0) : 0);
        bricks.push({ x: marginX + c*(brickW+gap), y: topY + r*(brickH+gap), w: brickW, h: brickH, hp, maxHp: hp, glow: 0 });
      }
    }
  }

  let audio = null;
  function initAudio() {
    if (audio) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    const actx = new AC();

    const master = actx.createGain();
    master.gain.value = 0.55;

    const music = actx.createGain();
    music.gain.value = 0.35;

    const sfx = actx.createGain();
    sfx.gain.value = 0.9;

    const comp = actx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.knee.value = 24;
    comp.ratio.value = 6;
    comp.attack.value = 0.003;
    comp.release.value = 0.15;

    music.connect(master);
    sfx.connect(master);
    master.connect(comp);
    comp.connect(actx.destination);

    let muted = false;
    function setMuted(m) {
      muted = m;
      master.gain.setTargetAtTime(muted ? 0 : 0.55, actx.currentTime, 0.01);
    }

    function tone(freq, dur, type="sine", gain=0.2, detune=0, when=0, out=sfx) {
      const t0 = actx.currentTime + when;
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      o.detune.setValueAtTime(detune, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(out);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    function noise(dur, gain=0.18, when=0) {
      const t0 = actx.currentTime + when;
      const bufferSize = Math.floor(actx.sampleRate * dur);
      const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
      const src = actx.createBufferSource();
      src.buffer = buffer;
      const g = actx.createGain();
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      const f = actx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.setValueAtTime(2400, t0);
      src.connect(f); f.connect(g); g.connect(sfx);
      src.start(t0);
      src.stop(t0 + dur + 0.02);
    }

    function sfxPaddle() { tone(220, 0.05, "triangle", 0.18); tone(440, 0.04, "sine", 0.08, 0, 0.01); }
    function sfxWall()   { tone(330, 0.05, "square", 0.10); }
    function sfxBrick(hp) { const base = hp >= 3 ? 140 : hp === 2 ? 180 : 240; tone(base, 0.06, "sawtooth", 0.16); tone(base*2, 0.04, "triangle", 0.08, 0, 0.01); }
    function sfxPower()  { tone(660, 0.08, "triangle", 0.16); tone(990, 0.10, "sine", 0.10, 0, 0.03); }
    function sfxLose()   { tone(196, 0.20, "sawtooth", 0.18); noise(0.18, 0.12, 0.05); }
    function sfxWin()    { tone(523.25,0.09,"triangle",0.18); tone(659.25,0.10,"triangle",0.16,0,0.10); tone(783.99,0.12,"triangle",0.14,0,0.22); }

    let musicOn = false, musicTimer = null, step = 0;
    const scale = [0, 3, 5, 7, 10];
    const root = 110;

    function startMusic() {
      if (musicOn) return;
      musicOn = true;
      const bpm = 118;
      const stepDur = 60 / bpm / 2;
      const pattern = [0,0,3,0,5,0,7,0,10,0,7,0,5,0,3,0];
      musicTimer = setInterval(() => {
        const intensity = clamp((combo/10) + (level-1)*0.08, 0, 1);
        const idx = pattern[step % pattern.length];
        const note = root * Math.pow(2, idx/12);
        tone(note, 0.10, "sine", 0.05 + 0.06*intensity, rand(-7,7), 0, music);
        if (step % 2 === 1) {
          const up = scale[Math.floor(Math.random()*scale.length)];
          const n2 = root*2 * Math.pow(2, up/12);
          tone(n2, 0.06, "triangle", 0.03 + 0.07*intensity, rand(-10,10), 0, music);
        }
        if (step % 4 === 2) noise(0.03, 0.03 + 0.04*intensity, 0);
        step++;
      }, stepDur * 1000);
    }

    function stopMusic() {
      if (!musicOn) return;
      musicOn = false;
      if (musicTimer) clearInterval(musicTimer);
      musicTimer = null;
    }

    audio = { actx, setMuted, get muted(){return muted;}, startMusic, stopMusic, sfxPaddle, sfxWall, sfxBrick, sfxPower, sfxLose, sfxWin };
  }

  async function ensureAudio() {
    initAudio();
    if (!audio) return;
    if (audio.actx.state !== "running") { try { await audio.actx.resume(); } catch {} }
  }

  let keys = { left:false, right:false };
  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft") keys.left = true;
    if (e.code === "ArrowRight") keys.right = true;

    if (e.code === "Space") {
      e.preventDefault();
      if (!startedOnce) startGame();
      else { paused = !paused; if (!paused && running) ensureAudio(); }
    }
    if (e.code === "KeyR") resetGame();
    if (e.code === "KeyM") toggleMute();
  });
  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft") keys.left = false;
    if (e.code === "ArrowRight") keys.right = false;
  });

  function pointerX(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (("touches" in ev) ? ev.touches[0].clientX : ev.clientX) - rect.left;
    return x * (W / rect.width);
  }
  canvas.addEventListener("mousemove", (e) => { paddle.targetX = pointerX(e); });
  canvas.addEventListener("touchstart", async (e) => {
    e.preventDefault();
    paddle.targetX = pointerX(e);
    await ensureAudio();
    if (!startedOnce) startGame();
  }, { passive:false });
  canvas.addEventListener("touchmove", (e) => {
    e.preventDefault();
    paddle.targetX = pointerX(e);
  }, { passive:false });
  canvas.addEventListener("mousedown", async () => {
    await ensureAudio();
    if (!startedOnce) startGame();
    else if (gameOver) resetGame();
    else if (!running) running = true;
  });

  function startGame() {
    startedOnce = true;
    running = true;
    paused = false;
    gameOver = false;
    ensureAudio();
    audio?.startMusic();
  }

  function resetGame() {
    score = 0; combo = 0; level = 1; lives = 3;
    gameOver = false; paused = false; running = true; laserTime = 0;
    powerups.length = 0; particles.length = 0; balls.length = 0;
    paddle.w = 160;
    buildLevel(level);
    spawnBall(paddle.x, paddle.y - 28, 1);
    if (startedOnce) { ensureAudio(); audio?.startMusic(); }
  }

  function nextLevel() {
    level++;
    combo = Math.floor(combo * 0.5);
    buildLevel(level);
    if (Math.random() < 0.35) {
      spawnBall(paddle.x, paddle.y - 28, 0.95);
      balls[balls.length-1].stuck = true;
    }
    shake = Math.max(shake, 10);
    audio?.sfxWin();
  }

  function circleRectCollide(cx, cy, r, rx, ry, rw, rh) {
    const px = clamp(cx, rx, rx+rw);
    const py = clamp(cy, ry, ry+rh);
    const dx = cx - px, dy = cy - py;
    return (dx*dx + dy*dy) <= r*r;
  }

  function reflectBallFromPaddle(b) {
    const hit = (b.x - paddle.x) / (paddle.w * 0.5);
    const t = clamp(hit, -1, 1);
    const speed = Math.hypot(b.vx, b.vy);
    const angle = lerp(-Math.PI*0.82, -Math.PI*0.18, (t+1)/2);
    b.vx = Math.cos(angle) * speed;
    b.vy = Math.sin(angle) * speed;
    const boost = 1.012 + clamp(combo,0,25) * 0.0008;
    b.vx *= boost; b.vy *= boost;
  }

  function spawnParticles(x, y, n, force=1) {
    for (let i=0;i<n;i++) {
      const a = rand(0, Math.PI*2);
      const sp = rand(1.5, 7.5) * force;
      particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rand(0.35, 0.9), max: 1, size: rand(2, 6) });
    }
  }

  function dropPowerup(brick) {
    const p = 0.08 + clamp(combo,0,20)*0.004 + (level-1)*0.01;
    if (Math.random() > p) return;
    const pick = Math.random();
    let type = "WIDE";
    if (pick < 0.28) type = "WIDE";
    else if (pick < 0.55) type = "SLOW";
    else if (pick < 0.78) type = "MULTI";
    else type = "LASER";
    powerups.push({ x: brick.x + brick.w/2, y: brick.y + brick.h/2, vy: 4.2, r: 14, type, spin: rand(0, Math.PI*2) });
  }

  function applyPowerup(type) {
    audio?.sfxPower();
    spawnParticles(paddle.x, paddle.y, 24, 1.1);
    shake = Math.max(shake, 8);
    if (type === "WIDE") paddle.w = clamp(paddle.w + 50, 140, 260);
    else if (type === "SLOW") for (const b of balls) { b.vx *= 0.85; b.vy *= 0.85; }
    else if (type === "MULTI") {
      const now = balls.slice();
      for (const b of now) {
        const sp = Math.hypot(b.vx, b.vy);
        const ang = Math.atan2(b.vy, b.vx) + rand(-0.35, 0.35);
        balls.push({ x:b.x, y:b.y, r:b.r, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, stuck:false, trail:[] });
      }
    } else if (type === "LASER") laserTime = 10.0;
  }

  function roundRect(c, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawBackground() {
    if (bgReady && bg.width && bg.height) {
      const imgW = bg.width, imgH = bg.height;
      const scale = Math.max(W/imgW, H/imgH);
      const dw = imgW*scale, dh = imgH*scale;
      const dx = (W - dw) * 0.5;
      const dy = (H - dh) * 0.5;
      ctx.drawImage(bg, dx, dy, dw, dh);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(0,0,W,H);
      const g = ctx.createRadialGradient(W*0.5,H*0.45, 10, W*0.5,H*0.55, Math.max(W,H)*0.75);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.45)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
    } else {
      ctx.fillStyle = "#0a0f18";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "700 18px system-ui, sans-serif";
      ctx.fillText("bg.jpg が読み込めません（同じフォルダに置いてください）", 26, 46);
    }
  }

  function drawHUD() {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "700 22px system-ui, sans-serif";
    ctx.fillText(`SCORE ${score.toString().padStart(7,"0")}`, 26, 42);
    ctx.font = "600 16px system-ui, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.fillText(`BEST ${best}`, 26, 66);
    ctx.fillText(`LV ${level}`, W - 98, 42);
    ctx.fillText(`LIFE ${lives}`, W - 114, 66);
    const meterW = 220, meterH = 10, cx = 26, cy = 86;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(cx, cy, meterW, meterH);
    const t = clamp(combo / 30, 0, 1);
    ctx.fillStyle = `rgba(255,255,255,${0.25 + 0.55*t})`;
    ctx.fillRect(cx, cy, meterW*t, meterH);
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.fillText(`COMBO x${combo}`, cx, cy + 26);
    if (laserTime > 0) {
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.fillText(`LASER ${laserTime.toFixed(1)}s`, W - 170, 90);
    }
    ctx.restore();
  }

  function drawPaddle() {
    ctx.save();
    const x = paddle.x - paddle.w/2, y = paddle.y - paddle.h/2;
    ctx.beginPath();
    roundRect(ctx, x, y, paddle.w, paddle.h, 10);
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.fill();
    const grad = ctx.createLinearGradient(0, y, 0, y+paddle.h);
    grad.addColorStop(0, "rgba(0,0,0,0.12)");
    grad.addColorStop(0.45, "rgba(0,0,0,0.00)");
    grad.addColorStop(1, "rgba(0,0,0,0.18)");
    ctx.fillStyle = grad;
    ctx.fill();
    if (laserTime > 0) {
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,0.30)";
      ctx.fillRect(x, y-6, paddle.w, 2);
      ctx.fillRect(x, y+paddle.h+4, paddle.w, 2);
    }
    ctx.restore();
  }

  function drawBricks() {
    for (const br of bricks) {
      if (br.hp <= 0) continue;
      const hpT = br.hp / br.maxHp;
      br.glow = Math.max(0, br.glow - 0.03);
      ctx.save();
      ctx.globalAlpha = 0.96;
      ctx.beginPath();
      roundRect(ctx, br.x, br.y, br.w, br.h, 8);
      const g = ctx.createLinearGradient(0, br.y, 0, br.y+br.h);
      g.addColorStop(0, `rgba(255,255,255,${0.20 + 0.35*hpT})`);
      g.addColorStop(1, `rgba(255,255,255,${0.06 + 0.18*hpT})`);
      ctx.fillStyle = g;
      ctx.fill();
      ctx.strokeStyle = `rgba(255,255,255,${0.18 + 0.35*hpT + br.glow})`;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(br.x+10, br.y+br.h-10, br.w-20, 4);
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.fillRect(br.x+10, br.y+br.h-10, (br.w-20)*hpT, 4);
      ctx.restore();
    }
  }

  function drawBalls() {
    for (const b of balls) {
      ctx.save();
      for (let i=0;i<b.trail.length;i++) {
        const t = b.trail[i];
        const a = i / b.trail.length;
        ctx.globalAlpha = 0.18 * (1-a);
        ctx.beginPath();
        ctx.arc(t.x, t.y, b.r*(0.7+0.3*(1-a)), 0, Math.PI*2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
      ctx.restore();
      ctx.save();
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fill();
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(b.x - b.r*0.25, b.y - b.r*0.25, b.r*0.45, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fill();
      ctx.restore();
    }
  }

  function drawPowerups() {
    for (const p of powerups) {
      ctx.save();
      p.spin += 0.08;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.spin);
      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.arc(0, 0, p.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fill();
      ctx.globalAlpha = 0.75;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.font = "800 12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(p.type[0], 0, 0);
      ctx.restore();
    }
  }

  function drawParticles(dt) {
    for (let i=particles.length-1;i>=0;i--) {
      const p = particles[i];
      p.life -= dt;
      if (p.life <= 0) { particles.splice(i,1); continue; }
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.98; p.vy = p.vy*0.98 + 0.12;
      const a = clamp(p.life / p.max, 0, 1);
      ctx.save();
      ctx.globalAlpha = 0.7 * a;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect(p.x, p.y, p.size, p.size);
      ctx.restore();
    }
  }

  function drawCenterText(title, sub) {
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "800 44px system-ui, sans-serif";
    ctx.fillText(title, W*0.5, H*0.52);
    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.font = "600 18px system-ui, sans-serif";
    ctx.fillText(sub, W*0.5, H*0.60);
    ctx.restore();
  }

  function toggleMute() {
    initAudio();
    if (!audio) return;
    audio.setMuted(!audio.muted);
  }

  function update(dt) {
    if (keys.left) paddle.targetX -= 840 * dt;
    if (keys.right) paddle.targetX += 840 * dt;
    paddle.targetX = clamp(paddle.targetX, paddle.w/2 + 10, W - paddle.w/2 - 10);
    paddle.x = lerp(paddle.x, paddle.targetX, 1 - Math.pow(1 - paddle.speed, dt*60));

    if (laserTime > 0) laserTime = Math.max(0, laserTime - dt);

    for (let i=balls.length-1;i>=0;i--) {
      const b = balls[i];
      if (b.stuck) {
        b.x = paddle.x; b.y = paddle.y - 28;
        if (startedOnce && (keys.left || keys.right || Math.abs(paddle.x - paddle.targetX) > 0.5)) b.stuck = false;
      } else {
        b.x += b.vx; b.y += b.vy;
      }

      b.trail.push({x:b.x, y:b.y});
      if (b.trail.length > 10) b.trail.shift();

      if (b.x - b.r < 12) { b.x = 12 + b.r; b.vx = Math.abs(b.vx); audio?.sfxWall(); combo = Math.max(0, combo-1); }
      if (b.x + b.r > W-12) { b.x = W-12 - b.r; b.vx = -Math.abs(b.vx); audio?.sfxWall(); combo = Math.max(0, combo-1); }
      if (b.y - b.r < 84) { b.y = 84 + b.r; b.vy = Math.abs(b.vy); audio?.sfxWall(); combo = Math.max(0, combo-1); }

      const rx = paddle.x - paddle.w/2, ry = paddle.y - paddle.h/2;
      if (circleRectCollide(b.x, b.y, b.r, rx, ry, paddle.w, paddle.h) && b.vy > 0) {
        b.y = ry - b.r - 0.5;
        reflectBallFromPaddle(b);
        audio?.sfxPaddle();
        shake = Math.max(shake, 5);
        spawnParticles(b.x, b.y, 10, 0.8);
      }

      for (const br of bricks) {
        if (br.hp <= 0) continue;
        if (circleRectCollide(b.x, b.y, b.r, br.x, br.y, br.w, br.h)) {
          const prevX = b.x - b.vx, prevY = b.y - b.vy;
          const hitFromLeft  = prevX <= br.x;
          const hitFromRight = prevX >= br.x + br.w;
          const hitFromTop   = prevY <= br.y;
          const hitFromBot   = prevY >= br.y + br.h;
          if (hitFromLeft || hitFromRight) b.vx *= -1;
          else if (hitFromTop || hitFromBot) b.vy *= -1;
          else b.vy *= -1;

          br.hp -= 1; br.glow = 0.7;

          combo += 1;
          score += 50 + Math.floor(combo*8) + Math.floor(level*6);
          shake = Math.max(shake, 7);
          spawnParticles(b.x, b.y, 18, 1.05);
          audio?.sfxBrick(br.hp+1);

          if (br.hp <= 0) {
            score += 60 + level*12;
            dropPowerup(br);
            spawnParticles(br.x+br.w/2, br.y+br.h/2, 22, 1.2);
          }
          break;
        }
      }

      if (b.y - b.r > H + 30) balls.splice(i, 1);
    }

    if (balls.length === 0) {
      lives--;
      combo = Math.floor(combo*0.35);
      audio?.sfxLose();
      shake = Math.max(shake, 14);
      if (lives <= 0) {
        gameOver = true;
        running = false;
        best = Math.max(best, score);
        localStorage.setItem("breakout_best", String(best));
        audio?.stopMusic();
      } else {
        spawnBall(paddle.x, paddle.y - 28, 1);
      }
    }

    for (let i=powerups.length-1;i>=0;i--) {
      const p = powerups[i];
      p.y += p.vy;
      if (p.y - p.r > H + 30) { powerups.splice(i,1); continue; }
      const rx = paddle.x - paddle.w/2, ry = paddle.y - paddle.h/2;
      if (circleRectCollide(p.x, p.y, p.r, rx, ry, paddle.w, paddle.h)) {
        powerups.splice(i,1);
        applyPowerup(p.type);
      }
    }

    if (laserTime > 0 && Math.random() < 0.14) {
      const candidates = bricks.filter(b => b.hp>0 && b.y < paddle.y - 80);
      if (candidates.length) {
        const target = candidates[Math.floor(Math.random()*candidates.length)];
        target.hp -= 1;
        target.glow = 0.9;
        combo += 1;
        score += 40 + Math.floor(combo*6);
        spawnParticles(target.x+target.w/2, target.y+target.h/2, 14, 1.0);
        shake = Math.max(shake, 5);
        audio?.sfxBrick(target.hp+1);
        if (target.hp <= 0) { score += 40; dropPowerup(target); }
      }
    }

    if (!bricks.some(b => b.hp > 0)) nextLevel();
    if (score > best) { best = score; localStorage.setItem("breakout_best", String(best)); }
  }

  function render(dt) {
    let sx = 0, sy = 0;
    if (shake > 0) {
      shake = Math.max(0, shake - 24*dt);
      sx = rand(-shake, shake);
      sy = rand(-shake, shake);
    }

    ctx.save();
    ctx.translate(sx, sy);

    drawBackground();
    drawHUD();
    drawBricks();
    drawPowerups();
    drawPaddle();
    drawBalls();
    drawParticles(dt);

    if (!startedOnce) drawCenterText("BREAKOUT", "クリック/タップ または Space で開始（音も有効化）");
    else if (paused) drawCenterText("PAUSED", "Space で再開 / R でリスタート / M でミュート");
    else if (gameOver) drawCenterText("GAME OVER", `SCORE ${score} / BEST ${best}（クリック or R で再挑戦）`);
    else if (balls.some(b => b.stuck)) {
      ctx.save();
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "700 16px system-ui, sans-serif";
      ctx.fillText("動かすとボールが発射されます", W*0.5, paddle.y - 68);
      ctx.restore();
    }

    ctx.restore();
  }

  // Boot + loop
  buildLevel(level);
  spawnBall(paddle.x, paddle.y - 28, 1);

  let last = performance.now();
  function loop(now) {
    const dt = clamp((now - last) / 1000, 0, 0.033);
    last = now;
    if (running && !paused && !gameOver) update(dt);
    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
